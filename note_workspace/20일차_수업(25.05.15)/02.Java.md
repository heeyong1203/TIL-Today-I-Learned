# 학습 정리 퀴즈
```html
1.다음 중 맞는 설명을 고르면?

(1) 상속을 이용하면 기존에 작성해 놓은 코드를 재사용할 수 있다.

(2) 상속 관계에서 재사용 가능성이 있는 코드는 부모 클래스에 정의하는데, 이때 부모를 Parent 클래스라 한다.

(3) 상속은 extends 키워드로 선언하는데, 만일 오리가 새를 상속받을 경우  Bird extends Duck 으로 선언한다.

(4) 부모를 상속받는 자식은 부모가 보유한 멤버 변수, 멤버 메서드를 물려받을 수 있다.

(5) 상속은 코드의 재사용성을 높일 수 있는 좋은 방법이기 때문에, 자식 클래스에서 extends 키워드를 최대한 많이 선언하여 부모의 수를 최대한 늘리는 것이 중요하다

```
- (2) : GUI에서 Parent / 부모 클래스 : Super()
- (3) : Duck extends Bird (extends=is a)
- (5) : 상속은 한 클래스로부터만 받을 수 있음 (다중 상속 금지)

```java
2.다음 설명 중 올바른 것을 모두 고르면? (부모 클래스 Bird가 정의되어 있다고 가정한다)

 class Duck extends Bird{

 }

(1) Bird 를 부모로 둔 Duck 클래스를 정의한 것이다.

(2) 이 클래스가 올바로 컴파일 되려면 Bird 클래스가 먼저 컴파일 되어 있어야 한다.

(3) Bird 를 부모 클래스라 하며 Java 에서는 Super 클래스라 표현한다.

(4) Duck 을 자식 클래스라 하며 Java 에서는 Child 클래스라 표현한다.

(5) 상속을 통해 Duck 은 자신의 멤버 변수, 멤버 메서드 이외에 부모의 멤버 변수, 메서드 까지도 보유하게 되므로, 자식은 기능 범위가 확장된(extends) 것으로 볼 수 있다.
```

- (4) : `super` : 부모 클래스 ↔ `sub` : 자식 클래스
- `extends`: 자식은 부모를 통해 기능 범위가 `확장`된 것으로 볼 수 있기 때문

```java
3.다음 중 맞는 설명은?

(1) 보편적이고 공통적인 특성이나 기능은 부모 클래스에 정의하고, 해당 객체만이 갖을 수 있는 특별한 특성 및 기능은 자식 클래스에 정의하는 것이 올바른 객체 지향 설계이다.

(2) 상속의 효과로 기능이 확장되는 쪽은 부모이다. 

(3) 아래의 코드와 같이 Duck 클래스에 Bird 를 상속하는 extends가 명시되어 있으면, 컴파일 시점에 Bird 와 Duck의 바이트 코드(.class) 는 내부적으로 결합되어 진다 
 
    class Duck extends Bird{

    }
     
(4) Bird 클래스가 보유한 재산을 자식이 물려받을 수 있으므로, Bird 클래스의 생성자도 당연히 물려받는다

(5) 자식 클래스의 초기화는 자식 스스로에게 책임이 있고, 부모가 대신해줄 수 없는 영역이므로 부모의 생성자는 물려받지 않는다
```
- (2) 자식의 기능이 확장됨
- (3) extends를 사용한다고, 컴파일된 파일이 결합되는 것이 아님 
- (4) 생성자의 목적 : 개성을 갖기 위한

```java
class Bird {
	private String name="새";
	boolean fly;
	public void fly(){
		System.out.println("부모가 날아요");
	}
}
class Duck extends Bird {
	String name="난 오리";
	public Duck(){
		(가)
	}
	public void fly(){ (라)
		System.out.println("자식이 날아요");
	}
}
class UseTest {
	public static void main(String[] args){
		Bird b=new Bird(); (나)
		Duck d=new Duck(); (다)
              b=d; (마) 
              b.fly(); (바)
	}
}
```
```html
4.다음 중 맞는 설명을 고르면? 

(1) 부모인 Bird에 이미 name 변수가 존재함에도 불구하고, 자식인 Duck 클래스에 동일한 
    이름의 name 변수를 선언하면, 자식의 변수는 부모의 변수에 의해 덮어씌워진다

(2) (라)에서 부모 클래스에 이미 존재하는 fly() 메서드를 자식이 중복 정의하였으므로 
    컴파일 에러가 발생할 것이다. 

(3) (나)에서 Bird 클래스의 인스턴스 뿐 아니라, 상속 관계의 자식인 Duck 클래스의 
    인스턴스도 생성된다.

(4) (가)에서 개발자가 명시하지 않더라도 이미 부모 클래스의 초기화를 위한 super() 
    호출코드가 숨겨져 있다

(5) (다)에 의해 Duck 뿐만 아니라, Bird 의 인스턴스도 메모리에 함께 생성된다.

(6) (마)에서 b가 갖는 주소값은 오리 인스턴스의 주소값이다

(7) (바)에서 b.fly() 는 오리가 물려받은 fly()를 호출했다기 보다는, Bird형 인스턴스를
    이용한 부모 메서드 호출로 보아야 한다. 
            
```
1. UseTest를 java.exe 실행 시 UseTest 클래스의 코드가 메모리에 올라감 (메서드 영역)
2. 메인을 만나면 메인 프레임 생성 (args, value=null 쌓임)
3. 실행부가 Bird b =new Bird(); 라인을 만나면 그제서야 Bird 클래스가 로드됨 (메서드 영역)
4. 메인 프레임에 변수 b 생성 후 heap 영역에 Bird 인스턴스 생성됨
5. 실행부가 Duck d = new Duck(); 라인을 만나면 그제서야 Duck 클래스가 로드됨 (메서드 영역)
6. Bird가 없었다면, Duck 실행 시 Duck보다 부모 클래스인 Bird가 먼저 생성되었을 것임 
7. 이 때, suoer() 호출 코드가 숨겨져 있음 
8. (Bird의 멤버 변수와 멤버 메서드가 Duck으로 확장되나, Bird가 생성되는 것은 아님)
9. Heap의 Duck 인스턴스에 Duck 고유의 멤버 변수 공간이 아닌 다른 공간에 Bird의 멤버 변수가 추가됨
10. 이 때의 extends 변수 공간을 super()라고 함
11. 이 때 private 변수라 할지라도 같이 들어옴 / 그러나 private이기 때문에 접근할 수 없음 
12. 메인프레임에 변수 d 생성 후 Duck 인스턴스 생성
13. b=d, 객체 자료형 간 형 변환이 가능한가??
14. extends=is a로 생각하라고 했음. 고로, 같은 자료형으로 생각할 수 있음
15. b=d; 변수 b의 주소값이 bird인스턴스가 아닌 duck인스턴스의 주소값으로 대체 됨
16. b.fly()는 결국, Duck의 fly 메서드를 호출하는 것
17. fly 메서드의 프레임이 stack이 쌓임 (자동적으로 this=b(오리 인스턴스)) this 바인딩에 의해...

- (2) 자식이 부모의 메서드를 오버라이딩 함 // 에러 X
- (5) 부모인 Bird의 초기화만 이루어질 뿐, 인스턴스가 생성되는 것은 아님

```java
package animal;
class Bird {
	protected String name="새";
	boolean fly;
	public Bird(Boolean f) {
		fly = f;
	}
}

package animal;
class Duck extends Bird {
	String sound="quack";
      public Duck(){
       }
}


package animal;
class UseTest {
	public static void main(String[] args){
	        Bird b=new Bird(); (가)
	        b.sound=”JJack JJack”; (나)
	        Duck d=new Duck(); (다)
	}
}

```

```html
5.좌측 클래스에 설명 중 맞는 것을 고르면? 

(1) (가)는 Bird 클래스를 메모리에 올리는 과정이므로 아무런 문제 없이 실행될
     것이다. (X)

(2) (나)의 코드는 문제가 없이 실행될 것이다. (x)

(3) (다)의 코드는 Duck 클래스를 메모리에 올리는 과정이므로 아무런 문제가 없다. (x)

(4) Duck 클래스는 부모인 Bird 클래스의 name 변수를 상속받지 못한다 (x)
    - protected는 상속관계에 있는 클래스끼리는 사용가능하므로, name변수에 접근 가능

(5) 현실과 마찬가지로, 자식보다 부모의 존재가 시점 상 우선해야 하므로, 상속 관계에 있는 
    자식 클래스의 인스턴스를 메모리에 올리려는 순간, 부모 클래스의 초기화 작업이 먼저 
    선행되어져야 한다 (O, 인스턴스 작업 X / 초기화 작업 O)

(6) 눈에 보이지는 않지만 Duck 클래스의 디폴트 생성자에는 개발자가 명시하지 않더라도     
    Bird 클래스 초기화를 위한 super() 코드가 생략되어 있다.

```

(4)
```java
package animal;
class Duck extends Bird {
	String sound="quack";
      public Duck(){
        // super()
       }
}
```
```html
6.다음 중 맞는 설명을 고르면?
(1) 객체 자료형도 Java 의 자료형 중 하나이므로 Java의 자료형의 종류는 총 4가지인 셈이다. (O)

(2) 기본 자료형 간 서로 비슷한 자료형일 경우 변환이 가능하듯, 만일 객체 자료형도 비슷한
    자료형이 존재한다면, 서로 간 형변환이가능해야 이치에 맞다. (o, extends=is a 관계)

(3) 기본 자료형은 서로 비슷한 자료형이 존재할 수 있지만, 객체 자료형도 비록 자료형이긴 하나, 
    서로 비슷한 자료형이라는 개념이 있을 수 없다. 

(4) 상속은 코드의 재사용성을 높이는 것 외에도, 상속 관계에 있는 객체 간은 서로 같은 종류의 자료형으로 인정받는 장점도 있다.
     
(5) 상속 관계에 있는 자료형은 서로 비슷한 자료형으로 인정되므로 형변환이 가능하다 

(6) extends 는 자식 클래스가 부모 클래스의 것을 물려받아 기능을 확장하는 의미도 있지만,  자료형 측면에서 보자면, 서로 같은 종류의 자료형으로 정의하는 효과도 있기 때문에 extends 를  is a 관계로 해석하기도 한다.

(7) 결국 Java 언어에서의 객체 간 관계는 2가지 유형이 있는데, 첫째는 객체가 여러 객체로 조합된 관계인 has a , 둘째는 객체 간의부모, 자식 관계를 is a 라 한다.

(8) 클래스 정의 시 개발자가 상속을 선언하지 않더라도, Java 에서는 디폴트로 강제 상속되어지는 최상위 부모클래스가 존재하는데,이 클래스를 Object라 한다. (O)

```

```html
7.다음 빈칸을 채워주세요

현실에 존재하는 모든 사물은 단독으로 존재할 수 없으며, 객체와 객체 사이에 관련성을 
맺으며 존재할 수 밖에 없다.
Java 언어에서는 특히 객체 간의 관계 중 부모와 자식 간 관계를 가리켜 ( is a ) 관계라 하며,
( extends ) 키워드로 선언한다

```

```java
public class Fish {
	String name="난 물고기";
      private int age=2; //(마)
}

public class Shark extends Fish{
	String name="난 상어";
}

public class UseAnimal {
	public static void main(String[] args) {
		Fish f = new Fish();
		Shark s = new Shark();
		f = s; //(가)
		s = f; //(나)
		
		Fish fish = new Shark(); //(다)
		Shark shark = new Fish(); //(라)
	}
}
```

```html
9.좌측 클래스에 설명 중 맞는 것을 고르면? 

(1) (가)에서 f는 Fish 형 객체를 대입해야 함에도, Shark 형인 s 를 대입하였으므로 자료형에 대한 컴파일 에러가 발생할 것이다. (x 객체형변환)

(2) (나)에서 Shark는 Fish 형과 같은 종류로 인정되므로,  s에 f 를 대입하는 것은 아무런 문제가 없다. (x, 자식에 부모를 대입하므로 강제형변환을 위해 캐스트연산자가 필요함)

(3) (다)는 상속 관계에 있는 Shark 자식형을 부모형인 Fish로 가리키고 있으므로 아무런 문제 없이 컴파일 될 것이다. (O)

(4) (나)에서 코드를  s = (Shark)f 로 다운 케스팅 할 경우 정상적으로 컴파일 될 것이다.
(O)

(5) 부모 자료형에서 자식 자료형으로 다운케스팅 할 경우, 데이터의 손실이 발생한다
(X, 데이터 용량을 기준으로 크고 작은 관계를 정의하는 것이 아니므로, 데이터 손실은 발생 X)

(6) Shark의 인스턴스가 생성될 때, (마)는 그 안에 포함되지 못한다. (x, 포함은 되지만 shark 고유 변수와 다른 공간에 포함됨, private이기 때문에 접근은 제한되어 있음)
```

다운캐스팅, 업캐스팅 (자료 공간을 위층, 아래층으로 나눴을 때 올라가냐, 내려가냐의 차이)

```html
10.다음 중 맞는 설명을 고르면?

(1) 상속 관계에서 자식 인스턴스 생성 시, 부모의 멤버 변수는 자식 인스턴스 영역에 편입되어지므로,  자식은 자신의 영역내에 부모 영역과 자신의 영역을 모두 보유하게 된다 (o)

(2) 위(1)번과 같은 원리로 인해서, 만일 자식이 부모와 동일한 멤버 변수를 보유한다고 해도 중복 정의 문제는 발생하지 않는다. (o)

(3) 자식은 자신이 보유한 영역에서 부모로 부터 물려받은 데이터 영역에 접근하기 위해, 부모 자료형으로 upcasting 하여 접근할 수 있다. (o)

(4) 자식이 부모의 메서드를 오버라이드 하였으나, 부모의 메서드를 호출하려면 부모 자료형으로 upcasting 하여 호출할 수 있다. (단독호출 X, super. 등 메서드를 통해 우회하여 호출해야 함)

(5) 일반적으로 상위 객체가 하위 객체보다 더 큰 byte 용량을 갖는 것으로 본다. (x)

(6) 상속 관계는 개념적 계층 구조에 따라 부모 자식이 결정되는 것이므로, 용량과 상관 없다.  (O)

(7) 객체 간 관계에서 있어, 상위 자료형은 하위 자료형보다 보유한 변수나 메서드 수는 적을 지라도, 가리킬 수 있는 객체의 범위는 더 넓다. (O, 가리킬 수 있는 객체의 범위가 더 넓음)
```

```java
public class Bird {
         int age=3;
	public void fly() {
		System.out.println("새가 날아요");
	}	
}
public class Sparrow extends Bird{
         int age=5;
	public void fly() {
		System.out.println("참새가 날아요");
	}	
}
public class Duck extends Bird{	
	public void fly() {
		System.out.println("오리가 날아요");
	}	
}


public class UseBird {
	public static void main(String[] args) {
	      Bird bird = new Bird();
               System.out.println(bird.age);//(마)
               bird.fly(); //(가)
	      bird=new Sparrow();
               bird.fly(); //(나)
	      bird=new Duck();
               bird.fly(); //(다)		
	      Bird b=new Bird();
	      Duck d=(Duck)b; (라)
	}
}
```

```html
11.좌측 클래스에 설명 중 맞는 것을 고르면? 
 
(1) (마)에서 Bird 의 멤버변수 age를 출력하게 되므로 3이 출력된다 (o)

(2) (가)에서 Bird 의 멤버 메서드가 호출되므로, “새가 날아요” 가 출력된다 (o)

(3) (나)의 실행 결과는 “새가 날아요” 이다. (x, 참새가 날아요)

(4) (다)에서 “오리가 날아요”가 출력된다. (o, 오리가 날아요)

(5) (라)에서 Bird 와 Duck은 같은 자료형이므로 다운케스팅에 아무런 문제가 없으나, 
      실행 시점에는 에러가 발생할 것이다. (o)

(6) bird 변수는 자료형이 Bird 형이지만 (가)에서는 그냥 새로,  (나)에서는 참새로 동작했으며 (다)에서는 오리로 동작했으므로, 결국 같은 자료형이 여러 가지 객체의 모습으로 동작했다고 볼 수 있으며, 이렇게 상위 객체의 자료형으로 자식객체의 메서드를 호출할 수 있는 기법을 가리켜  OOP 언어는 다형성(Polymorphism) 이라 한다. (o)

```
### 다형성 - 종은 같으나, 각 개체가 서로 다른 특징을 가져 뚜렷하게 구별되는 현상
- 매우 많이 쓰이는 기법 (프레임워크 등에 자주 쓰임)

#### 업캐스팅과 다운캐스팅, 오버라이딩에 대한 혼동이 발생하므로, 문제를 더 풀어보자
